/*
 *  $URL$
 *  $Author$
 *  $Date$
 *  
 *  $Copyright-Start$
 *
 *  Copyright (c) 2010
 *  RedPrairie Corporation
 *  All Rights Reserved
 *
 *  This software is furnished under a corporate license for use on a
 *  single computer system and can be copied (with inclusion of the
 *  above copyright) only for use on such a system.
 *
 *  The information in this document is subject to change without notice
 *  and should not be construed as a commitment by RedPrairie Corporation.
 *
 *  RedPrairie Corporation assumes no responsibility for the use of the
 *  software described in this document on equipment which has not been
 *  supplied or approved by RedPrairie Corporation.
 *
 *  $Copyright-End$
 */

package com.redprairie.moca.servlet;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.concurrent.Callable;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorCompletionService;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

import org.junit.After;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;

import com.redprairie.moca.server.ServerUtils;
import com.redprairie.moca.server.exec.LocalSessionContext;
import com.redprairie.moca.server.exec.SessionContext;
import com.redprairie.moca.server.exec.SessionType;
import com.redprairie.moca.servlet.WebSessionManager.ClosedSessionCallback;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

/**
 * This class is to test the session manager.  Unfortunately the way the
 * manager works is that it must know about a session if it is to do operations
 * on them.  And currently only sessions that are generated by the session
 * manager are known so many tests intrinsically test the 
 * {@link WebSessionManager#generateNewSessionContext(java.util.Map)} method.
 * 
 * Copyright (c) 2010 RedPrairie Corporation
 * All Rights Reserved
 * 
 * @author wburns
 */
public class TU_WebSessionManager {

    /**
     * @throws Exception
     */
    @BeforeClass
    public static void setUpBeforeClass() throws Exception {
        ServerUtils.setupDaemonContext(
                TU_WebSessionManager.class.getName(), true);
    }
    
    /**
     * @throws Exception
     */
    @Before
    public void setupBefore() throws Exception {
        // We default the session timeout to 200 milliseconds
        _manager = new WebSessionManager(_timeout, _unit, _maxSessions, _callback);
    }
    
    @After
    public void tearDownAfter() throws Exception {
        _manager.close();
    }
    
    /**
     * This test is not enabled, since it is called by another multiple times
     * Test method for {@link com.redprairie.moca.servlet.WebSessionManager#registerIdle(com.redprairie.moca.server.exec.SessionContext)}.
     * @throws InterruptedException
     */
    public void testRegisterIdle() throws InterruptedException {
        SessionContext context = _manager.generateNewSessionContext(null);
        CountDownLatch latch = new CountDownLatch(1);
        context.putAttribute(LATCH, latch);
        long timeout = _timeout;
        
        long begin = System.nanoTime();
        _manager.registerIdle(context);
        
        // We wait twice as long long as the timeout to make sure it has time.
        assertTrue("The session was not closed fast enough", 
                latch.await(timeout * 10, _unit));
        long total = System.nanoTime() - begin;
        // Convert the other unit down to nanoseconds so we can be really precise.
        long convertedMin = TimeUnit.NANOSECONDS.convert(timeout, _unit);
        assertTrue("We only waited " + total
                + " - should have been at least " + convertedMin, 
                total > convertedMin);
    }

    /**
     * Test method for {@link com.redprairie.moca.servlet.WebSessionManager#registerIdle(com.redprairie.moca.server.exec.SessionContext)}.
     */
    @Test
    public void testRegisterIdleNoSessions() {
        try {
            _manager.registerIdle(_dummyContext);
            fail("We should have received an IllegalStateException");
        }
        catch (IllegalStateException e) {
            // Should go here.
        }
    }

    /**
     * Test method for {@link com.redprairie.moca.servlet.WebSessionManager#closeSession(com.redprairie.moca.server.exec.SessionContext)}.
     * @throws InterruptedException 
     */
    @Test
    public void testCloseSession() throws InterruptedException {
        SessionContext context = _manager.generateNewSessionContext(null);
        CountDownLatch latch = new CountDownLatch(1);
        context.putAttribute(LATCH, latch);
        
        _manager.closeSession(context);
        
        assertEquals("The session was not closed properly", 0, latch.getCount());
    }
    
    /**
     * Test method for {@link com.redprairie.moca.servlet.WebSessionManager#getIdleSession(java.lang.String)}.
     * @throws InterruptedException 
     */
    @Test
    public void testGetIdleSessionButRunning() throws InterruptedException {
        // This will mark this session as active.
        SessionContext context = _manager.generateNewSessionContext(null);
        
        try {
            _manager.getIdleSession(context.getSessionId());
            fail("The session was running, so we should have gotten an error");
        }
        catch (SessionRunningException e) {
            // Should go here
        }
    }
    
    /**
     * Test method for {@link com.redprairie.moca.servlet.WebSessionManager#getIdleSession(java.lang.String)}.
     * @throws SessionRunningException 
     * @throws InterruptedException 
     */
    @Test
    public void testGetIdleSessionButRunning2() throws SessionRunningException, InterruptedException {
        // This will mark this session as active.
        SessionContext context = _manager.generateNewSessionContext(null);
        
        // We put it back to idle
        _manager.registerIdle(context);
        
        // We then put it back to active
        context = _manager.getIdleSession(context.getSessionId());
        
        // This check is in case if the session got cleaned up after being marked
        // as idle.  This can happen if the computer is running very slowly.
        // If this isn't here then the next get idle will return a null context 
        // as well and not throw an error.
        if (context != null) {
        
            try {
                // It should be active, so this should error.
                _manager.getIdleSession(context.getSessionId());
                fail("The session was running, so we should have gotten an error");
            }
            catch (SessionRunningException e) {
                // Should go here
            }
        }
    }
    
    /**
     * Test method for {@link com.redprairie.moca.servlet.WebSessionManager#generateNewSessionContext(java.util.Map)}.
     * @throws InterruptedException 
     */
    @Test
    public void testGenerateNewSessionContext() throws InterruptedException {
        Map<String, String> env = new HashMap<String, String>();
        SessionContext session = _manager.generateNewSessionContext(env);
        
        // Check to make sure it has all the environment variables.
        for (Entry<String, String> entry : env.entrySet()) {
            assertEquals(entry.getValue(), session.getVariable(entry.getKey()));
        }
    }
    
    /**
     * Try registering idle and keepalive sessions from multiple threads at
     * the same time.  We then verify that those sessions time out properly.
     * @throws InterruptedException This is thrown if for some reason we were
     *         interrupted.  Shouldn't happen.
     * @throws ExecutionException This is thrown if one of the registers failed.
     * @throws TimeoutException 
     */
    @Test
    public void testRegisterAlotAsynchronously() throws InterruptedException, ExecutionException, TimeoutException {
        // We create threads in the number of processors + 1.  This way we
        // always have at least 2 and slightly more to increase throughput since
        // we are doing a lot of waiting.
        int processors = Runtime.getRuntime().availableProcessors();
        ExecutorService executor = Executors.newFixedThreadPool(processors + 1);
        ExecutorCompletionService<Void> service = 
            new ExecutorCompletionService<Void> (executor);
        int total = 250;
        
        for (int i = 0; i < total; i++) {
            service.submit(new Callable<Void>() {

                @Override
                public Void call() throws Exception {
                    testRegisterIdle();
                    return null;
                }
                
            });
        }
       
        // Now try to retrieve all the threads results, mainly we care
        // if an exception occurred.
        for (int i = 0; i < total; i++) {
            Future<Void> future = service.poll(5, TimeUnit.SECONDS);
            assertNotNull("Must have gotten stuck!", future);
            future.get();
        }
    }
    
    @Test
    public void testReachMaxSessions() throws InterruptedException, 
            ExecutionException, TimeoutException {
        List<SessionContext> contextes = new ArrayList<SessionContext>(_maxSessions);
        
        // First we fill up all the max sessions.
        for (int i = 0; i < _maxSessions; i++) {
            SessionContext context = _manager.generateNewSessionContext(null);
            assertNotNull("The context returned was null", context);
            contextes.add(context);
        }
        
        ExecutorService service = Executors.newSingleThreadExecutor();
        
        try {
            Callable<SessionContext> callable = new Callable<SessionContext>() {

                @Override
                public SessionContext call() throws Exception {
                    return _manager.generateNewSessionContext(null);
                }
                
            };
            
            Future<SessionContext> future = service.submit(callable);
            
            // We wait 50 milliseconds for it to timeout as it should.
            try {
                future.get(50L, TimeUnit.MILLISECONDS);
                fail("For some reason we got a context, when the max sessions was full");
            }
            catch (TimeoutException e) {
                // We should have timed out.
            }
            
            // We return all the sessions back to being idle, which should
            // our waiting session to continue forward.
            for (SessionContext context : contextes) {
                _manager.registerIdle(context);
            }
            
            // This should return now.
            SessionContext context = future.get(1L, TimeUnit.SECONDS);
            
            assertNotNull("The context returned was null", context);
        }
        finally {
            service.shutdown();
        }
    }
    
    @Test
    public void testRegisterAndCloseAlotAsynchronously() throws InterruptedException, ExecutionException {
        ExecutorService executor = Executors.newFixedThreadPool(_maxSessions * 10);
        ExecutorCompletionService<Void> service = 
            new ExecutorCompletionService<Void> (executor);
        int total = 1000;
        
        try {
            for (int i = 0; i < total; i++) {
                service.submit(new Callable<Void>() {
    
                    @Override
                    public Void call() throws Exception {
                        SessionContext context = _manager.generateNewSessionContext(null);
                        
                        _manager.registerIdle(context);
                        
                        SessionContext context2 = _manager.getIdleSession(context.getSessionId());
                        if (context2 == null) {
                            context2 = _manager.generateNewSessionContext(null);
                        }
                        _manager.closeSession(context2);
                        return null;
                    }
                    
                });
            }
           
            // Now try to retrieve all the threads results, mainly we care
            // if an exception occurred.
            for (int i = 0; i < total; i++) {
                // 5 Seconds should be more than enough time to wait.
                Future<Void> future = service.poll(5, TimeUnit.SECONDS);
                assertNotNull("Must have gotten stuck!", future);
                future.get();
            }
        }
        finally {
            executor.shutdown();
        }
    }
    
    private static class TestCallback implements ClosedSessionCallback {

        // @see com.redprairie.moca.servlet.MocaSessionManager.ClosedSessionCallback#onSessionClose(com.redprairie.moca.server.exec.SessionContext)
        @Override
        public void onSessionClose(SessionContext sessionContext) {
            Object obj = sessionContext.getAttribute(LATCH);
            if (obj != null) {
                ((CountDownLatch)obj).countDown();
            }
        }
    }

    private static final String LATCH = "latch";
    private static final long _timeout = 200;
    private static final int _maxSessions = 10;
    private static final TimeUnit _unit = TimeUnit.MILLISECONDS;
    private static final TestCallback _callback = new TestCallback();
    
    private WebSessionManager _manager;
    private SessionContext _dummyContext = new LocalSessionContext("dummy", 
        SessionType.TASK);
}
