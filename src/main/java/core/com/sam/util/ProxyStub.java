/*
 *  $URL$
 *  $Revision$
 *  $Author$
 *  $Date$
 *  
 *  $Copyright-Start$
 *
 *  Copyright (c) 2016
 *  Sam Corporation
 *  All Rights Reserved
 *
 *  This software is furnished under a corporate license for use on a
 *  single computer system and can be copied (with inclusion of the
 *  above copyright) only for use on such a system.
 *
 *  The information in this document is subject to change without notice
 *  and should not be construed as a commitment by Sam Corporation.
 *
 *  Sam Corporation assumes no responsibility for the use of the
 *  software described in this document on equipment which has not been
 *  supplied or approved by Sam Corporation.
 *
 *  $Copyright-End$
 */

package com.sam.util;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.security.AccessController;
import java.security.PrivilegedAction;

/**
 * Generic proxy implementation to allow partial implementations of an
 * interface to be referred to by the interface.  All methods that are
 * not implemented will throw <code>NotImplementedException</code>.
 * 
 * <strong>Note</strong>: The proxies generated by this class will forward
 * calls to the <code>equals</code> method the same as any other method.
 * One implication of this is that two identical or equal objects that are
 * proxied by a proxy stub will generally not produce proxies that compare
 * equal.  I.e. for some proxy <code>p</code>, instantiated through this
 * class, the expression
 * <pre>
 * p.equals(p)
 * </pre>
 * will probably evaluate as <code>false</code>.  This violates the stated
 * contract of {@link Object#equals}.  Therefore proxy stubs should not be
 * used in places where object equality is important.

 *
 * <b><pre>
 * Copyright (c) 2016 Sam Corporation
 * All rights reserved.
 * </pre></b>
 *
 * @author  Derek Inksetter
 * @version $Revision$
 */
public class ProxyStub {
    
    /**
     * Create a new proxy that implements a single interface.
     * @param cls the interface to be proxied.
     * @param target the target of the proxy
     * @return a proxy object that will call methods on <code>target</code>,
     * if they exist.  This object can be safely cast to the interface passed
     * in as <code>cls</code>.
     */    
    @SuppressWarnings("unchecked")
    public static <T> T newProxy(Class<T> cls, Object target) {
        
        // Since the proxy object returned is guaranteed to implement our
        // passed-in interface, this cast is OK.
        return (T) newProxy(new Class<?>[] {cls}, target);
    }
    
    /**
     * Creates a new proxy object that implements the interaces defined by
     * <code>classes</code>.  Whenever a method is invoked, this proxy looks
     * up the method with the same name and arguments on the target and calls
     * it.  The target object passed in need not implement any of the
     * interfaces defined by <code>classes</code>.
     * @param classes the interfaces to be proxied. This argument must not
     * be null.
     * @param target the target object that will be searched for all methods.
     * For each method, if it exists on <code>target</code>, the method on
     * <code>target</code> will be called.  Otherwise, or if
     * <code>target</code> is null, a <code>NotImplementedException</code>
     * will be thrown.
     * @return a proxy object that will call methods on <code>target</code>,
     * if they exist.  This object can be safely cast to any interface passed
     * in as <code>classes</code>.
     */   
    public static Object newProxy(Class<?>[] classes, Object target) {
        return newProxy(classes, target, null);
    }
    
    /**
     * Creates a new proxy object that implements the interaces defined by
     * <code>classes</code>.  Whenever a method is invoked, this proxy looks
     * up the method with the same name and arguments on the target and calls
     * it.  The target object passed in need not implement any of the
     * interfaces defined by <code>classes</code>.
     * @param classes the interfaces to be proxied.  This argument must not
     * be null.
     * @param target the target object that will be searched for all methods.
     * For each method, if it exists on <code>target</code>, the method on
     * <code>target</code> will be called.  Otherwise, or if
     * <code>target</code> is null, a <code>NotImplementedException</code>
     * will be thrown.
     * @param loader the classloader to be used to load the generated proxy
     * stub.  If this argument is null, the thread's context classloader
     * will be used.  Care must be taken that the classloader used to load
     * the target proxy has visibility to all implemented interfaces.
     * @return a proxy object that will call methods on <code>target</code>,
     * if they exist.  This object can be safely cast to any interface passed
     * in as <code>classes</code>.
     */   
    public static Object newProxy(Class<?>[] classes, Object target,
                                  ClassLoader loader) {
        ArgCheck.notNull(classes);
        if (loader == null) {
            loader = ClassUtils.getClassLoader();
        }
        
        return Proxy.newProxyInstance(loader, classes, new _Handler(target));
    }
    
    //
    // Implementation
    //
    
    private static class _Handler implements InvocationHandler {
        _Handler(Object target) {
            _target = target;
        }
        
        @Override
        public Object invoke(Object proxy, Method m, Object[] args) throws Throwable {
            Class<?> declaringClass = m.getDeclaringClass();

            if (declaringClass == Object.class && m.equals(equalsMethod)) { 
                return proxyEquals(proxy, args[0]);
            }
            else {
                return proxyInvoke(proxy, m, args);
            }
        }
        
        // @see java.lang.Object#equals(java.lang.Object)
        @Override
        public boolean equals(Object obj) {
            if (!(obj instanceof _Handler)) {
                return false;
            }
            if (_target == null) {
                return false;
            }
            return this._target.equals(((_Handler)obj)._target);
        }

        public boolean proxyEquals(Object proxy, Object proxy2) {
            if (proxy == proxy2) {
                return true;
            }
            
            if (proxy == null || proxy2 == null) {
                return false;
            }
            
            if (!(proxy instanceof Proxy) || !(proxy2 instanceof Proxy)) {
                return false;
            }
            
            // If they are proxies now we fall back to their handler's equals
            // methods.  The first one should be a _Handler object
            InvocationHandler handler = Proxy.getInvocationHandler(proxy);
            InvocationHandler handler2 = Proxy.getInvocationHandler(proxy2);
            
            return handler.equals(handler2);
        }
        
        // Javadoc inherited from interface        
        public Object proxyInvoke(Object proxy, Method method, Object[] args)
                throws Throwable {
            if (_target == null) {
                throw new NotImplementedException("Method " + 
                        method + " not implemented");
            }
            
            // Look for this method on our wrapped object.
            final Method targetMethod;
            try {
                Class<?> cls = _target.getClass();
                targetMethod = cls.getMethod(
                        method.getName(), method.getParameterTypes());
            }                        
            catch (NoSuchMethodException e) {
                throw new NotImplementedException("Method " + 
                        method + " not implemented");
            }
            
            // Return types must match.  The class objects must compare
            // equal.
            Class<?> ifcReturn = method.getReturnType();
            Class<?> implReturn = targetMethod.getReturnType();
            if (!ifcReturn.equals(implReturn)) {
                throw new NotImplementedException("Method " + 
                        method + " returns the wrong type");
            }
          
            // Set the method accessible to allow inner classes to be used
            AccessController.doPrivileged(new PrivilegedAction<Void>() {
                @Override
                public Void run() {
                    targetMethod.setAccessible(true);
                    return null;
                }
                
            });
            
            // Invoke the discovered method on the target object.
            try {
                return targetMethod.invoke(_target, args);
            }
            catch (InvocationTargetException e) {
                throw e.getTargetException();
            }
        }

        private final Object _target;
    }
    
    // preloaded Method objects for the methods in java.lang.Object
    private static final Method equalsMethod;
    static {
        try {
            equalsMethod = Object.class.getMethod("equals", new Class[] { Object.class });
        }
        catch (NoSuchMethodException e) {
            throw new NoSuchMethodError(e.getMessage());
        }
    }
}
